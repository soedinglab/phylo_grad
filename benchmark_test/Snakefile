localrules: random_phylo, random_fasta, sim_phy, phy_to_fasta, collect_iqtree_benchmark

rule random_phylo:
    output: ensure("data/random/tree_{num_leafs}.nwk", non_empty=True)
    # There is a chance reroot fails because it cannot find a suitable root, we just try again, because we just want a random tree
    retries: 5
    shell: "nw_reroot -d <(phylotree generate -t {wildcards.num_leafs} -b) > {output}"

rule random_fasta:
    input: "data/random/tree_{num_leafs}.nwk"
    output: "data/random/alignment_{num_leafs}_{L}.fasta"
    shell: "python random_fasta.py {input[0]} {wildcards.L} {output[0]}"

rule sim_phy:
    input: "data/random/tree_{num_leafs}.nwk"
    output: "data/sim/alignment_{num_leafs}_{L}.phy"
    run:
      shell(f"iqtree --alisim {output[0][:-4]} -t {input} --length {wildcards.L} -m LG")

rule phy_to_fasta:
    input: "data/sim/alignment_{num_leafs}_{L}.phy"
    output: "data/sim/alignment_{num_leafs}_{L}.fasta"
    shell: "seqret -sequence {input} -outseq {output}"

def benchmark_input(wildcards):
    num_leafs = [2**n for n in [4,6,8,10,12,14]]
    L = [wildcards.L] * len(num_leafs)

    newick = [f"data/random/tree_{n}.nwk" for n in num_leafs]
    fasta = [f"data/random/alignment_{n}_{l}.fasta" for n,l in zip(num_leafs,L)]

    return newick + fasta

rule benchmark:
    input: files = benchmark_input, script = "benchmark.py"
    output: "data/random/time_t={num_t}_L={L}_m={method}.pickle"
    threads: lambda w : int(w.num_t)
    resources:
        slurm_extra= lambda w: "-G A100:1" if w.method == "jax_gpu" or w.method == "pytorch_gpu" else "--exclusive",
        mem_mb=450000,
        runtime=1000
    shell: "OMP_NUM_THREADS={threads} RAYON_NUM_THREADS={threads} python benchmark.py {output} f32,f64 {wildcards.method} {input.files}"

rule benchmark_iqtree:
    input: tree = "data/random/tree_{num_leafs}.nwk",
           alignment = "data/sim/alignment_{num_leafs}_{L}.fasta"
    output: "data/sim/alignment_{num_leafs}_{L}_{num_t}.iqtree.log",
    threads: lambda w: int(w.num_t)
    resources:
        slurm_extra="--exclusive",
        mem_mb=210000,
        runtime=10000
    shell: "/bin/time -v ./iqtree3 -s {input.alignment} -nt {wildcards.num_t} --model GTR20+FO --redo -te {input.tree} -blfix -pre {output} &> {output}"

rule benchmark_raxml:
    input: tree = "data/random/tree_{num_leafs}.nwk",
           alignment = "data/sim/alignment_{num_leafs}_{L}.fasta"
    output: "data/sim/alignment_{num_leafs}_{L}_{num_t}.raxml.log",
    threads: lambda w: int(w.num_t)
    resources:
        slurm_extra="--exclusive",
        mem_mb=210000,
        runtime=10000
    shell: "/bin/time -v ./raxml-ng --msa {input.alignment} --model PROTGTR+FO --tree {input.tree} --evaluate --opt-branches off --threads {wildcards.num_t} --redo --prefix {output} &> {output}"

# Rule to the the optimized PAML file using phylograd to check that is matches iqtree/raxml
rule benchmark_phylograd_paml:
    input: tree = "data/random/tree_{num_leafs}.nwk",
           alignment = "data/sim/alignment_{num_leafs}_{L}.fasta",
           script = "optimize_global_model.py"
    output: "data/sim/alignment_{num_leafs}_{L}_{num_t}.phylograd.paml"
    threads: lambda w: int(w.num_t)
    resources:
        slurm_extra="--exclusive",
        mem_mb=210000,
        runtime=1000
    shell: "RAYON_NUM_THREADS={wildcards.num_t} python optimize_global_model.py --fasta_amino {input.alignment} --newick {input.tree} --output {output}"

rule benchmark_phylograd:
    input: tree = "data/random/tree_{num_leafs}.nwk",
           alignment = "data/sim/alignment_{num_leafs}_{L}.fasta",
    output: "data/sim/alignment_{num_leafs}_{L}_{num_t}.phylograd.log"
    threads: lambda w: int(w.num_t)
    resources:
        slurm_extra="--exclusive",
        mem_mb=210000,
        runtime=1000
    shell: "RAYON_NUM_THREADS={wildcards.num_t} /bin/time -v ../target/release/gtr_optimize {input.tree} {input.alignment} global &> {output}"


rule collect_iqtree_benchmark:
    input: iqtree = expand("data/sim/alignment_{num_leafs}_{L}.fasta.iqtree.time", num_leafs=[2**n for n in [4,6,8,10,12]], L=[100,500]),
           phylograd = expand("data/sim/alignment_{num_leafs}_{L}.fasta.phylograd.time", num_leafs=[2**n for n in [4,6,8,10,12]], L=[100,500])
    output: "data/iqtree_benchmark.txt"
    shell: "tail -n +1 {input.iqtree} {input.phylograd} > {output}"

rule collect_iqtree_likelihoods:
    input: iqtree = expand("data/sim/alignment_{num_leafs}_{L}.fasta.iqtree", num_leafs=[2**n for n in [4,6,8,10,12]], L=[100,500])
    output: "data/iqtree_likelihoods.txt"
    shell: "grep -H 'Log-likelihood of the tree' {input.iqtree} > {output}"

rule collect_phylograd_likelihoods:
    input: phylograd = expand("data/sim/alignment_{num_leafs}_{L}.fasta.phylograd.npz", num_leafs=[2**n for n in [4,6,8,10,12]], L=[100,500])
    output: "data/phylograd_likelihoods.txt"
    run:
        import numpy as np
        with open(output[0], "w") as out:
            for f in input.phylograd:
                data = np.load(f)
                out.write(f"{f}: {data['log_p']}\n")
